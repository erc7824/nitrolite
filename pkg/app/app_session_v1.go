package app

import (
	"fmt"
	"time"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/shopspring/decimal"
)

type AppStateUpdateIntent uint8

const (
	AppStateUpdateIntentOperate AppStateUpdateIntent = iota
	AppStateUpdateIntentDeposit
	AppStateUpdateIntentWithdraw
	AppStateUpdateIntentClose
)

func (intent AppStateUpdateIntent) String() string {
	switch intent {
	case AppStateUpdateIntentOperate:
		return "operate"
	case AppStateUpdateIntentDeposit:
		return "deposit"
	case AppStateUpdateIntentWithdraw:
		return "withdraw"
	case AppStateUpdateIntentClose:
		return "close"
	default:
		return "unknown"
	}
}

type AppSessionStatus uint8

const (
	AppSessionStatusVoid AppSessionStatus = iota
	AppSessionStatusOpen
	AppSessionStatusClosed
)

func (status AppSessionStatus) String() string {
	switch status {
	case AppSessionStatusVoid:
		return ""
	case AppSessionStatusOpen:
		return "open"
	case AppSessionStatusClosed:
		return "closed"
	default:
		return "unknown"
	}
}

// AppSessionV1 represents an application session in the V1 API.
type AppSessionV1 struct {
	SessionID    string
	Application  string
	Participants []AppParticipantV1
	Quorum       uint8
	Nonce        uint64
	Status       AppSessionStatus
	Version      uint64
	SessionData  string
	CreatedAt    time.Time
	UpdatedAt    time.Time
}

// AppParticipantV1 represents the definition for an app participant.
type AppParticipantV1 struct {
	WalletAddress   string
	SignatureWeight uint8
}

// AppDefinitionV1 represents the definition for an app session.
type AppDefinitionV1 struct {
	Application  string
	Participants []AppParticipantV1
	Quorum       uint8
	Nonce        uint64
}

// AppAllocationV1 represents the allocation of assets to a participant in an app session.
type AppAllocationV1 struct {
	Participant string
	Asset       string
	Amount      decimal.Decimal
}

// AppStateUpdateV1 represents the current state of an application session.
type AppStateUpdateV1 struct {
	AppSessionID string
	Intent       AppStateUpdateIntent
	Version      uint64
	Allocations  []AppAllocationV1
	SessionData  string
}

// AppSessionInfoV1 represents information about an application session.
type AppSessionInfoV1 struct {
	AppSessionID string
	IsClosed     bool
	Participants []AppParticipantV1
	SessionData  string
	Quorum       uint8
	Version      uint64
	Nonce        uint64
	Allocations  []AppAllocationV1
}

// SessionKeyV1 represents a session key with spending allowances.
type SessionKeyV1 struct {
	ID          uint
	SessionKey  string
	Application string
	Allowances  []AssetAllowanceV1
	Scope       *string
	ExpiresAt   time.Time
	CreatedAt   time.Time
}

// AssetAllowanceV1 represents an asset allowance with usage tracking.
type AssetAllowanceV1 struct {
	Asset     string
	Allowance decimal.Decimal
	Used      decimal.Decimal
}

// PackCreateAppSessionRequestV1 packs the Definition and SessionData for signing using ABI encoding.
// This is used to generate a deterministic hash that participants sign when creating an app session.
func PackCreateAppSessionRequestV1(definition AppDefinitionV1, sessionData string) ([]byte, error) {
	// Define the participant tuple type
	participantType, err := abi.NewType("tuple", "", []abi.ArgumentMarshaling{
		{Name: "walletAddress", Type: "address"},
		{Name: "signatureWeight", Type: "uint8"},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create participant type: %w", err)
	}

	// Define the arguments structure
	args := abi.Arguments{
		{Type: abi.Type{T: abi.StringTy}},                        // application
		{Type: abi.Type{T: abi.SliceTy, Elem: &participantType}}, // participants array
		{Type: abi.Type{T: abi.UintTy, Size: 8}},                 // quorum (uint8)
		{Type: abi.Type{T: abi.UintTy, Size: 64}},                // nonce (uint64)
		{Type: abi.Type{T: abi.StringTy}},                        // sessionData
	}

	// Convert participants to the format expected by ABI packing
	participants := make([]struct {
		WalletAddress   common.Address
		SignatureWeight uint8
	}, len(definition.Participants))

	for i, p := range definition.Participants {
		participants[i] = struct {
			WalletAddress   common.Address
			SignatureWeight uint8
		}{
			WalletAddress:   common.HexToAddress(p.WalletAddress),
			SignatureWeight: p.SignatureWeight,
		}
	}

	// Pack the data using ABI encoding
	packed, err := args.Pack(
		definition.Application,
		participants,
		definition.Quorum,
		definition.Nonce,
		sessionData,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to pack app session request: %w", err)
	}

	// Return the Keccak256 hash of the packed data
	return crypto.Keccak256(packed), nil
}

// PackAppStateUpdateV1 packs the AppStateUpdate for signing using ABI encoding.
// This is used to generate a deterministic hash that participants sign when updating an app session state.
func PackAppStateUpdateV1(stateUpdate AppStateUpdateV1) ([]byte, error) {
	// Define the allocation tuple type
	allocationType, err := abi.NewType("tuple", "", []abi.ArgumentMarshaling{
		{Name: "participant", Type: "address"},
		{Name: "asset", Type: "string"},
		{Name: "amount", Type: "string"},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create allocation type: %w", err)
	}

	// Define the arguments structure
	args := abi.Arguments{
		{Type: abi.Type{T: abi.FixedBytesTy, Size: 32}},         // appSessionID (bytes32)
		{Type: abi.Type{T: abi.UintTy, Size: 8}},                // intent (uint8)
		{Type: abi.Type{T: abi.UintTy, Size: 64}},               // version (uint64)
		{Type: abi.Type{T: abi.SliceTy, Elem: &allocationType}}, // allocations array
		{Type: abi.Type{T: abi.StringTy}},                       // sessionData
	}

	// Convert allocations to the format expected by ABI packing
	allocations := make([]struct {
		Participant common.Address
		Asset       string
		Amount      string
	}, len(stateUpdate.Allocations))

	for i, a := range stateUpdate.Allocations {
		allocations[i] = struct {
			Participant common.Address
			Asset       string
			Amount      string
		}{
			Participant: common.HexToAddress(a.Participant),
			Asset:       a.Asset,
			Amount:      a.Amount.String(),
		}
	}

	// Convert app session ID from hex string to bytes32
	appSessionIDHash := common.HexToHash(stateUpdate.AppSessionID)

	// Pack the data using ABI encoding
	packed, err := args.Pack(
		appSessionIDHash,
		stateUpdate.Intent,
		stateUpdate.Version,
		allocations,
		stateUpdate.SessionData,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to pack app state update: %w", err)
	}

	// Return the Keccak256 hash of the packed data
	return crypto.Keccak256(packed), nil
}

// GenerateAppSessionIDV1 generates a deterministic app session ID from the definition using ABI encoding.
func GenerateAppSessionIDV1(definition AppDefinitionV1) (string, error) {
	// Define the participant tuple type
	participantType, err := abi.NewType("tuple", "", []abi.ArgumentMarshaling{
		{Name: "walletAddress", Type: "address"},
		{Name: "signatureWeight", Type: "uint8"},
	})
	if err != nil {
		return "", fmt.Errorf("failed to create participant type: %w", err)
	}

	// Define the arguments structure
	args := abi.Arguments{
		{Type: abi.Type{T: abi.StringTy}},                        // application
		{Type: abi.Type{T: abi.SliceTy, Elem: &participantType}}, // participants array
		{Type: abi.Type{T: abi.UintTy, Size: 8}},                 // quorum (uint8)
		{Type: abi.Type{T: abi.UintTy, Size: 64}},                // nonce (uint64)
	}

	// Convert participants to the format expected by ABI packing
	participants := make([]struct {
		WalletAddress   common.Address
		SignatureWeight uint8
	}, len(definition.Participants))

	for i, p := range definition.Participants {
		participants[i] = struct {
			WalletAddress   common.Address
			SignatureWeight uint8
		}{
			WalletAddress:   common.HexToAddress(p.WalletAddress),
			SignatureWeight: p.SignatureWeight,
		}
	}

	// Pack the data using ABI encoding
	packed, err := args.Pack(
		definition.Application,
		participants,
		definition.Quorum,
		definition.Nonce,
	)
	if err != nil {
		return "", fmt.Errorf("failed to pack app definition: %w", err)
	}

	// Return the Keccak256 hash as hex string
	return crypto.Keccak256Hash(packed).Hex(), nil
}
