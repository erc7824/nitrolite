import { Address, encodeAbiParameters, keccak256 } from 'viem';
import {
  AppDefinitionV1,
  AppStateUpdateV1,
  AppSessionKeyStateV1,
  AppSessionVersionV1,
} from './types';

/**
 * PackCreateAppSessionRequestV1 packs the Definition and SessionData for signing using ABI encoding.
 * This is used to generate a deterministic hash that participants sign when creating an app session.
 */
export function packCreateAppSessionRequestV1(
  definition: AppDefinitionV1,
  sessionData: string
): `0x${string}` {
  // Define the participant tuple type components
  const participantComponents = [
    { name: 'walletAddress', type: 'address' },
    { name: 'signatureWeight', type: 'uint8' },
  ] as const;

  // Convert participants to the format expected by ABI packing
  const participants = definition.participants.map((p) => ({
    walletAddress: p.walletAddress,
    signatureWeight: p.signatureWeight,
  }));

  // Pack the data using ABI encoding
  const packed = encodeAbiParameters(
    [
      { type: 'string' }, // application
      { type: 'tuple[]', components: participantComponents }, // participants array
      { type: 'uint8' }, // quorum
      { type: 'uint64' }, // nonce
      { type: 'string' }, // sessionData
    ],
    [
      definition.application,
      participants,
      definition.quorum,
      definition.nonce,
      sessionData,
    ]
  );

  // Return the Keccak256 hash of the packed data
  return keccak256(packed);
}

/**
 * PackAppStateUpdateV1 packs the AppStateUpdate for signing using ABI encoding.
 * This is used to generate a deterministic hash that participants sign when updating an app session state.
 */
export function packAppStateUpdateV1(stateUpdate: AppStateUpdateV1): `0x${string}` {
  // Define the allocation tuple type components
  const allocationComponents = [
    { name: 'participant', type: 'address' },
    { name: 'asset', type: 'string' },
    { name: 'amount', type: 'string' },
  ] as const;

  // Convert allocations to the format expected by ABI packing
  const allocations = stateUpdate.allocations.map((a) => ({
    participant: a.participant,
    asset: a.asset,
    amount: a.amount.toString(),
  }));

  // Convert app session ID from hex string to bytes32
  const appSessionIdHash = stateUpdate.appSessionId as `0x${string}`;

  // Pack the data using ABI encoding
  const packed = encodeAbiParameters(
    [
      { type: 'bytes32' }, // appSessionID
      { type: 'uint8' }, // intent
      { type: 'uint64' }, // version
      { type: 'tuple[]', components: allocationComponents }, // allocations array
      { type: 'string' }, // sessionData
    ],
    [
      appSessionIdHash,
      stateUpdate.intent,
      stateUpdate.version,
      allocations,
      stateUpdate.sessionData,
    ]
  );

  // Return the Keccak256 hash of the packed data
  return keccak256(packed);
}

/**
 * GenerateAppSessionIDV1 generates a deterministic app session ID from the definition using ABI encoding.
 */
export function generateAppSessionIDV1(definition: AppDefinitionV1): `0x${string}` {
  // Define the participant tuple type components
  const participantComponents = [
    { name: 'walletAddress', type: 'address' },
    { name: 'signatureWeight', type: 'uint8' },
  ] as const;

  // Convert participants to the format expected by ABI packing
  const participants = definition.participants.map((p) => ({
    walletAddress: p.walletAddress,
    signatureWeight: p.signatureWeight,
  }));

  // Pack the data using ABI encoding
  const packed = encodeAbiParameters(
    [
      { type: 'string' }, // application
      { type: 'tuple[]', components: participantComponents }, // participants array
      { type: 'uint8' }, // quorum
      { type: 'uint64' }, // nonce
    ],
    [definition.application, participants, definition.quorum, definition.nonce]
  );

  // Return the Keccak256 hash as hex string
  return keccak256(packed);
}

/**
 * GenerateRebalanceBatchIDV1 creates a deterministic batch ID from session versions using ABI encoding.
 * The batch ID is generated by hashing the list of (sessionID, version) pairs.
 */
export function generateRebalanceBatchIDV1(
  sessionVersions: AppSessionVersionV1[]
): `0x${string}` {
  // Define the session version tuple type components
  const sessionVersionComponents = [
    { name: 'sessionID', type: 'bytes32' },
    { name: 'version', type: 'uint64' },
  ] as const;

  // Convert session versions to the format expected by ABI packing
  const sessionVersionsArray = sessionVersions.map((sv) => ({
    sessionID: sv.sessionId as `0x${string}`,
    version: sv.version,
  }));

  // Pack the data using ABI encoding
  const packed = encodeAbiParameters(
    [
      { type: 'tuple[]', components: sessionVersionComponents }, // session versions array
    ],
    [sessionVersionsArray]
  );

  // Return the Keccak256 hash as hex string
  return keccak256(packed);
}

/**
 * GenerateRebalanceTransactionIDV1 creates a deterministic transaction ID for a rebalance transaction using ABI encoding.
 */
export function generateRebalanceTransactionIDV1(
  batchId: string,
  sessionId: string,
  asset: string
): `0x${string}` {
  // Pack the data using ABI encoding
  const packed = encodeAbiParameters(
    [
      { type: 'bytes32' }, // batchID
      { type: 'bytes32' }, // sessionID
      { type: 'string' }, // asset
    ],
    [batchId as `0x${string}`, sessionId as `0x${string}`, asset]
  );

  // Return the Keccak256 hash as hex string
  return keccak256(packed);
}

/**
 * PackAppSessionKeyStateV1 packs the app session key state for signing using ABI encoding.
 * Matches Go SDK's PackAppSessionKeyStateV1.
 *
 * @param state - The app session key state to pack
 * @returns Keccak256 hash of the ABI-encoded state (excluding user_sig)
 */
export function packAppSessionKeyStateV1(state: AppSessionKeyStateV1): `0x${string}` {
  const applicationIDHashes = state.application_ids.map(
    (id) => id as `0x${string}`
  );
  const appSessionIDHashes = state.app_session_ids.map(
    (id) => id as `0x${string}`
  );

  const packed = encodeAbiParameters(
    [
      { type: 'address' },    // user_address
      { type: 'address' },    // session_key
      { type: 'uint64' },     // version
      { type: 'bytes32[]' },  // application_ids
      { type: 'bytes32[]' },  // app_session_ids
      { type: 'uint64' },     // expires_at
    ],
    [
      state.user_address as Address,
      state.session_key as Address,
      BigInt(state.version),
      applicationIDHashes,
      appSessionIDHashes,
      BigInt(state.expires_at),
    ]
  );

  return keccak256(packed);
}
